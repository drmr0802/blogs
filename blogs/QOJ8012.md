---
layout: default
title: QOJ8012.
---

## 题意

给定树 $T = (V, E)$，点有颜色 $C \in \{0, 1\}$，初始为 $0$。维护数据结构：

- `0 x` 将点 $x$ 权值变为 $0$；
- `1 x` 将点 $x$ 权值变为 $1$；
- `2` 对于所有点 $U$，点 $u$ 的权值**同时**变为 $[\exist v, (u, v) \in E \wedge C_v = 1]$。注意 $v \ne u$。

## 题解

以下设 $1$ 为树根。称 `0` 操作、`1` 操作为赋值操作，`2` 操作为交换操作。称叶子节点为方点（L），非方点为圆点（R）。记一个点的圆点儿子个数为 $\text{Rcnt}$，方点儿子个数为 $\text{Lcnt}$，父亲为 $\text{Fa}$。

定义一个结构（structer）：

1. 维护每一个圆点的颜色 $c$；
2. 维护每一个圆点的方点儿子权值和 $\text{Ltot}$。需要支持单点修改查询，全局修改查询；
3. 维护每一个圆点的圆点儿子中，权值为 $0$ 的集合。需要支持插入，删除，遍历；
4. 维护一个集合，名为 $\text{cache}$。

对于结构的第 2 部分，可以通过维护标记和记录标记产生时间，方点修改时间来解决。

记第 $i$ 次操作后，树的状态为 $T_i$。若题中只有交换操作，则满足 $T_{i + 2}$ 中权值为 $1$ 的点是 $T_i$ 中的超集。因此，定义两个结构 $\text{Now}, \text{Nxt}$。$\text{Now}$ 维护 $T_i$，$\text{Nxt}$ 维护 $T_{i + 1}$。

通过上面的方法，定义函数 $\text{Color}(x)$ 表示方点 $x$ 的权值 $C_x$。

```cpp
inline int Color(int u){
	if(dfn[u] > dfn[fa[u]]) return c[u];
	return tag[fa[u]];
}
```

定义函数 $\text{nxtColor}(x)$ 表示圆点 $x$ 在 $T_{i + 1}$ 中的权值 $C'_x$。

```cpp
inline int nxtColor(int u){
	if(c[fa[u]]) return 1; // 如果父亲的颜色为 1，则这个点也会变为 1
	if(ltot[u]) return 1; // 如果方儿子中有点颜色为 1，则这个点也会变为 1
	return st[u].size() < rcnt[u]; // 如果圆儿子中 0 的个数比总共的圆儿子个数少，则会变为 1
}
```

定义函数 $\text{ModifyL, ModifyR}$ 表示修改方点，圆点的权值。

```cpp
void modifyL(int u, int x){
	dfn[u] = ++dfncnt, c[u] = x; // 更改修改的时间
	ans += (x ? 1 : -1);
	ltot[fa[u]] += (x ? 1 : -1); // 计算父亲的贡献
	return ;
}
void modifyR(int u, int x){
	c[u] = x, ans += (x ? 1 : -1);
	if(fa[u]){
		if(x) st[fa[u]].erase(u);
		else st[fa[u]].insert(u);
	} // 修改父亲的 st
	return ;
}
```

定义函数 $\text{ModifyS}(u, x)$ 表示把圆点 $u$ 的所有方儿子权值改为 $x$。

```cpp
void modifyS(int u, int x){
	dfn[u] = ++dfncnt, tag[u] = x;
	ans -= ltot[u];
	ans += (ltot[u] = lcnt[u] * x);
	return ;
}
```

**一个维护 $T_i$ 的结构的缓存（$\text{cache}$）用来记录，修改 $T_i$ 中点的权值造成对 $T_{i + 1}$ 的修改**，即：将 $T_i$ 修改对 $T_{i + 1}$ 点造成的影响在交换操作时延后计算。

以下的修改操作额外增加了记录缓存：

```cpp
void modifyLwithCache(int u, int x, structer *p){
	if(p->Color(u) == x) return ;
	now->cache.pb(fa[u]); // 在 now 中加入缓存，是因为 fa 的值会影响被修改，不再正确的 u
	nxt->cache.pb(fa[u]); // 在 nxt 中加入缓存，是应为 fa 的值会收到更改的 u 的影响
	p->modifyL(u, x);
	return ;
}
void modifyRwithCache(int u, int x, structer *p){
	if(p->c[u] == x) return ;
	now->cache.pb(u);
	nxt->cache.pb(u);
	if(fa[u]) p->cache.pb(fa[u]);
	p->modifyR(u, x);
	return ;
}
```

接着，实现交换操作 $\text{Swaps}$：

```cpp
void swaps(){
	basic_string<int> cache;
	cache.swap(now->cache);
	for(int u : cache){
		if(uniq[u]) continue; uniq[u] = 1; // 去重
		int c = now->c[u], nc = now->nxtColor(u);
		nxt->modifyS(u, c); // 方儿子的权值会也仅会收到 u 的影响
		modifyRwithCache(u, nc, nxt); // u 的节点会变为 nxtColor(u)

		if(c){
			if(fa[u]) modifyRwithCache(fa[u], 1, nxt);
			unordered_set<int> st;
			st.swap(nxt->st[u]);
			for(int j : st)
				modifyRwithCache(j, 1, nxt);
		} // 更改其他会收到点 u 影响的点
	}
	for(int u : cache) uniq[u] = 0;
	swap(now, nxt); // 由于执行了一次操作，交换 now 和 nxt
	return ;
}
```

这样就实现完成了。
